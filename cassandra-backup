#!/usr/bin/env bash -ue

# cassandra-backup
# USAGE: cassandra-backup snapshot-tag

# A simple backup tool for Cassandra that smartly copies snapshotted SSTables to a separate directory tree, preferably
# on a separate (possibly remote) filesystem.

# Only non-system keyspaces are copied.

# A dump of the current schema and token range is also stored alongside each snapshot.

# The smart copy feature leverages the immutable nature of SSTables. This tool attempts to create hardlinks to existing
# SSTables where possible. If a SSTable is already present in a previous snapshot in the destination tree this tool will
# hardlink that SSTable into the new snapshot directory, rather than copying it from the Cassandra data directory.
# Obviously this requires a destination filesystem that supports hardlinks.

echoerr() { echo "cassandra-backup:" "$@" 1>&2; }
normalize_path() { echo "$(cd $(dirname "${@}");pwd)/$(basename "${@}")"; }

#nodetool() { ccm node1 nodetool -- "${@}"; }
#cqlsh() { ccm node1 cqlsh -- "${@}"; }

: "${NODETOOL:=nodetool}"
: "${CQLSH:=cqlsh}"

: "${CASSANDRA_DATA_DIRECTORY:="/var/lib/cassandra/data"}"
: "${BACKUP_ROOT_DIRECTORY:="/backups/cassandra/$(hostname)"}"

SYSTEM_SCHEMA_KEYSPACES_TABLE="system.schema_keyspaces" # TODO: make this version aware (2.x is system.*, 3.x is system_schema.*)

snapshot_name="$1"

backup_snapshot_directory="${BACKUP_ROOT_DIRECTORY}/${snapshot_name}"

# take the snapshot
echoerr "Taking snapshot..."
"${NODETOOL}" snapshot -t "${snapshot_name}"

# find and smart copy the snapshot to the backup location
while read -d '' -r snapshot_file; do
	# remove the snapshot directory from the file path
	data_file=$(sed -e "s|./||; s|/snapshots/${snapshot_name/|/\|}||" <<< "${snapshot_file}")

	snapshot_file=$(normalize_path "${CASSANDRA_DATA_DIRECTORY}/${snapshot_file}")

	backup_file="${backup_snapshot_directory}/${data_file}"
	mkdir -p "$(dirname "${backup_file}")"

	# find existing copy of the data file in the backup directory and hard link it
	while read -d '' -r existing_file; do
		echoerr "${backup_file}: Hardlinking existing snapshot file ${existing_file}"
		ln "${existing_file}" "${backup_file}" \
			&& continue 2 \
			|| true; # try to hardlink. if successful, continue the outer loop, otherwise...

		# ...fall through to the copy
		break;
	done < <(find "${BACKUP_ROOT_DIRECTORY}" -path "*${data_file}" -print0)

	# otherwise, hard link or, (if that fails, i.e, x-device) copy the data file to the backup directory
	echoerr "${backup_file}: Copying from ${snapshot_file}"
    ln "${snapshot_file}" "${backup_file}" 2> /dev/null \
    	|| cp "${snapshot_file}" "${backup_file}"

# find every non-system keyspace data file for the named snapshot, ignoring manifests and schema dumps
done < <(cd "${CASSANDRA_DATA_DIRECTORY}" && find . \( -path "./system*" -prune -quit \) \
			-o -path "./*/*/snapshots/${snapshot_name}/*" ! \( -name "*.json" -o -name "*.cql" \) -print0 )


# schema dump (this includes the keyspace definitions, unlike the per-table dumps generated by Cassandra)
echoerr "${backup_snapshot_directory}/schema.cql: Dumping CQL schema..."
"${CQLSH}" -e "COPY ${SYSTEM_SCHEMA_KEYSPACES_TABLE} (keyspace_name) TO STDOUT" \
	| grep -v "system" \
	| xargs -n 1 -I % "${CQLSH}" -e "DESCRIBE KEYSPACE %" \
	> "${backup_snapshot_directory}/schema.cql"

# token range dump
echoerr "${backup_snapshot_directory}/initial_token.yaml: Dumping token range..."
"${CQLSH}" -e "COPY system.local (tokens) TO STDOUT" \
	| sed -e "s/[\"{}']//g; s/^/initial_token: /" \
	> "${backup_snapshot_directory}/initial_token.yaml"